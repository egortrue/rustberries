// Функция `as_chan` принимает вектор `i32` и возвращает приемник канала
// Внутри функции создается канал, запускается поток, который отправляет элементы вектора по каналу
fn as_chan(vs: &[i32]) -> std::sync::mpsc::Receiver<i32> {
    // Создаем канал для передачи данных.
    let (tx, rx) = std::sync::mpsc::channel();

    // Запускаем новый поток, который будет отправлять элементы вектора по каналу
    let handle = std::thread::spawn({
        // Копируем вектор, так как он будет использоваться в новом потоке
        let vs = vs.to_owned();

        // Прячем копирование вектора в замыкании.
        move || {
            // Отправляем элементы вектора по каналу, делая паузу между каждым элементом
            for v in vs {
                tx.send(v).unwrap();
                std::thread::sleep(std::time::Duration::from_secs(1))
            }

            // Останавливаем поток, сбросив канал отправки
            drop(tx);
        }
    });

    // Ждем завершения потока.
    handle.join().unwrap();

    // Возвращаем приемник канала.
    rx
}

// Функция `merge` принимает два приемника каналов и возвращает новый приемник канала
// внутренний цикл считывает элементы из обоих каналов и передает их по новому каналу
fn merge(
    a: std::sync::mpsc::Receiver<i32>,
    b: std::sync::mpsc::Receiver<i32>,
) -> std::sync::mpsc::Receiver<i32> {
    // Создаем новый канал для приема данных.
    let (tx, rx) = std::sync::mpsc::channel();

    // Логические переменные для отслеживания завершения чтения из каналов
    let mut a_done = false;
    let mut b_done = false;

    // Основной цикл для поочередного считывания данных из каналов и записи их в новый канал
    loop {
        match a.try_recv() {
            Ok(i) => {
                tx.send(i).unwrap();
            }
            Err(_) => {
                a_done = true;
            }
        };

        match b.try_recv() {
            Ok(i) => {
                tx.send(i).unwrap();
            }
            Err(_) => {
                b_done = true;
            }
        };

        if a_done && b_done {
            break;
        }
    }

    // Возвращаем приемник нового канала.
    rx
}

fn main() {
    // Создаем и ожидаем завершения трэда, который отправляет элементы вектора по каналу.
    let a = as_chan(&vec![1, 3, 5, 7]);

    // Создаем и ожидаем завершения другого трэда, который отправляет элементы вектора по каналу.
    let b = as_chan(&vec![2, 4, 6, 8]);

    // Соединяем два канала и создаем новый канал с объединенными данными.
    let c = merge(a, b);

    // Печатаем элементы из объединенного канала.
    for v in c.iter() {
        println!("{v:?}");
    }

    /* Вывод

    1
    2
    3
    4
    5
    6
    7
    8

    */
}
